//
//  main.c
//  demo27
//
//  Created by weichen on 15/3/25.
//  Copyright (c) 2015年 weichen. All rights reserved.
//

#include <stdio.h>

int main(int argc, const char * argv[]) {
    //
    printf("sizeof(char)=%ld\n", sizeof(char));         //1 字节（8bite）
    printf("sizeof(short)=%ld\n", sizeof(short));       //2 字节
    printf("sizeof(int)=%ld\n", sizeof(int));           //4 取决于编译器（cpu），通常的意义是“1个字”
    printf("sizeof(long)=%ld\n", sizeof(long));         //8 取决于编译器（cpu），通常的意义是“1个字”
    printf("sizeof(long long)=%ld\n", sizeof(long long));//8 8字节

    //gcc ./test.c -o -m32  #以32平台架构编译显示
    
    
    char c = 255;
    int i = 255;
    printf("c=%d, i=%d\n", c, i); //c=-1, d=255
    
    unsigned char d = 255;        //用来表示整数不以补码的形式表示，看做纯二进制
    printf("d=%d\n", d);            //d=255
    
    char e = 127;
    e = e + 1;
    printf("e=%d\n", e);          //-128
    
    unsigned char f = 127;
    f = f + 1;
    printf("f=%d\n", f);          //128
    
    return 0;
}

//int 是用来表达寄存器的
/*
 计算机以二进制表达正整数，表达负数用补码：
 
    0  ->  00000000
    1  ->  00000001
 
    11111111 + 00000001 -> 1000000000 \
                                      |
    00000000 - 00000001 -> （负1）     |
                                      |
 (1)00000000 - 00000001 -> 11111111   /

   ① 11111111被当做纯二进制时，是255，被当作补码时，是-1
   ② 同样，对于-a，实际是(2^n - 1)，n是这种类型的位数；补码是0-a
   ③ 补码的意思是拿补码和原码可以加出一个溢出的“零”
*/


//数的范围
/*
 一个字节（8位），表达的是：
 00000000 - 11111111

 其中，00000000 -> 0
     11111111 ~ 10000000 -> -1 ~ -128   //用补码表示
00000001 ~ 01111111 -> 1 ~ 127          //纯二进制表示
*/

//unsigned
/*
 如果一个字面量常数想要表达自己是unsigned，可以在后面加u或U
    255U
 用l或L表示long（long）
 unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位。
 */

//整数越界
/*
 整数是以纯二进制方式进行计算的，所以：
 11111111 + 1 -> 100000000 -> 0
 01111111 + 1 -> 10000000  -> -128
 10000000 - 1 -> 01111111  -> 127
 */

//整数的输入输出
/*
 只有两种形式：int或long long
 %d：int
 %u：unsigned
 %ld：long long
 %lu：unsigned long long
 */

//8进制和16进制
/*
 一个以0开始的数字字面量是8进制
 一个以0x开始的数字字面量是16进制
 %o用于8进制，%x用于16进制
 8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关
 
 16进制很适合表达二进制数据，因为4位二进制正好是一个16进制位
 8进制的一位数字正好表达3位二进制
    因为早期计算机的字长是12的倍数，而非8
 */

//选择整数类型
/*
 为什么整数要有那么多种？
    为了准确表达内存，做底层程序的需要
 没有特殊需要，就选择int
    现在的CPU的字长普遍是32位或64位，一次内存读写就是一个int，一次计算也是一个int，选择更短的类型不会更快，甚至可能更慢
    现代的编译器一般会涉及内存对齐，所以更短的类型实际在内存中有可能也占据一个int的大小（虽然sizeof告诉你更小）
 unsigned与否只是输出的不同，内部计算是一样的，所以现代高级语言大多已不区分非负。
 */